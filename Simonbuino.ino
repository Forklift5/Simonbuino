/***** SIMONBUINO v2 ****** SIMON (1978 electronic game by Ralph Bauer) clone
- coded by Jerom (April 2015)
- sound FX made with FX Synth by yodasvideoarcade http://gamebuino.com/forum/viewtopic.php?f=17&t=1018 */

#include <SPI.h>//imports the SPI library (needed to communicate with Gamebuino's screen)
#include <Gamebuino.h>//imports the Gamebuino library
Gamebuino gb;//creates a Gamebuino object named gb

//BITMAPS
const byte titleBitmap[] PROGMEM = {64, 30, 0x0, 0x1F, 0xE0, 0x0, 0x79, 0xB1, 0x9E, 0x63, 0x0, 0xFF, 0xFC, 0x0, 0xFD, 0xBB, 0xBF, 0x73, 0x3, 0xFF, 0xFF, 0x0, 0xFD, 0xBF, 0xBF, 0x7B, 0x7, 0xFF, 0xFF, 0x80, 0xED, 0xBF, 0xBF, 0x7F, 0xB, 0xE0, 0x1F, 0x40, 0xE1, 0xBF, 0xB7, 0x7F, 0x13, 0x9F, 0xE7, 0x20, 0xF9, 0xBF, 0xB3, 0x7F, 0x3E, 0x6A, 0xB9, 0xF0, 0x7D, 0xB5, 0xB3, 0x6F, 0x3C, 0xD5, 0x5C, 0xF0, 0x1D, 0xB1, 0xBF, 0x67, 0x7D, 0xEA, 0xAE, 0xF8, 0xFD, 0xB1, 0xBF, 0x63, 0x7B, 0xF5, 0x5F, 0x78, 0xF9, 0xB1, 0x9E, 0x63, 0x7A, 0xFA, 0xBB, 0x78, 0x0, 0x0, 0x0, 0x0, 0xF4, 0x3F, 0xFD, 0xBC, 0xF8, 0xCD, 0xB1, 0x9E, 0xF5, 0x58, 0x6A, 0xBC, 0xFC, 0xCD, 0xB1, 0xBF, 0xF4, 0x10, 0x37, 0xBC, 0xCC, 0xCD, 0xB9, 0xBF, 0xF6, 0xB4, 0xAA, 0xBC, 0xFC, 0xCD, 0xBD, 0xB3, 0xF4, 0x10, 0x3D, 0xBC, 0xFE, 0xCD, 0xBF, 0xB3, 0xF5, 0x53, 0x2A, 0xBC, 0xEE, 0xDD, 0xBF, 0xB7, 0xF4, 0x18, 0x77, 0xBC, 0xE6, 0xFD, 0xBF, 0xBF, 0xF6, 0xBF, 0xFA, 0xBC, 0xE6, 0xFD, 0xB7, 0xBF, 0x7A, 0x70, 0x3D, 0x78, 0xFE, 0xFD, 0xB3, 0xBF, 0x7B, 0xE0, 0x1F, 0x78, 0xFC, 0x79, 0xB1, 0x9E, 0x7D, 0xC0, 0xE, 0xF8, 0x0, 0x0, 0x0, 0x0, 0x3C, 0xC0, 0xC, 0xF0, 0x0, 0x1, 0xC1, 0x80, 0x3E, 0x60, 0x19, 0xF0, 0x6, 0x53, 0xE0, 0xA0, 0x13, 0x9F, 0xE7, 0x20, 0x7, 0x73, 0x6C, 0x90, 0xB, 0xE0, 0x1F, 0x40, 0x7, 0x23, 0xEA, 0xB5, 0x7, 0xFF, 0xFF, 0x80, 0x0, 0x3, 0xEA, 0xD5, 0x3, 0xFF, 0xFF, 0x17, 0x67, 0x73, 0x6D, 0xBB, 0x0, 0xFF, 0xFC, 0x16, 0x77, 0x70, 0x8, 0x1, 0x0, 0x1F, 0xE0, 0x77, 0x57, 0x53, 0xE8, 0x6,};
const byte frameBitmap[] PROGMEM = {64, 48, 0x0, 0x3F, 0xFF, 0xE0, 0x7, 0xFF, 0xFC, 0x0, 0x0, 0x7F, 0xFF, 0x0, 0x0, 0xFF, 0xFE, 0x0, 0x0, 0xFF, 0xF8, 0x3F, 0xFC, 0x1F, 0xFF, 0x0, 0x1, 0xFF, 0xF1, 0xFF, 0xFF, 0x8F, 0xFF, 0x80, 0x1, 0xFF, 0xC7, 0xE0, 0x7, 0xE3, 0xFF, 0x80, 0x3, 0xFF, 0x9F, 0x0, 0x0, 0xF9, 0xFF, 0xC0, 0x7, 0xFF, 0x3C, 0x0, 0x0, 0x3C, 0xFF, 0xE0, 0x7, 0xFE, 0x78, 0x0, 0x0, 0x1E, 0x7F, 0xE0, 0xF, 0xFC, 0xF0, 0x0, 0x0, 0xF, 0x3F, 0xF0, 0x1F, 0xF9, 0xF0, 0x0, 0x0, 0xF, 0x9F, 0xF8, 0x1F, 0xF3, 0xF8, 0x0, 0x0, 0x1F, 0xCF, 0xF8, 0x1F, 0xF7, 0xF8, 0x0, 0x0, 0x1F, 0xEF, 0xF8, 0x3F, 0xE7, 0x3C, 0x0, 0x0, 0x3C, 0xE7, 0xFC, 0x3F, 0xCE, 0xE, 0x0, 0x0, 0x70, 0x73, 0xFC, 0x7F, 0xCC, 0x7, 0x7, 0xE0, 0xE0, 0x33, 0xFE, 0x7F, 0xDC, 0x3, 0x9F, 0xF9, 0xC0, 0x3B, 0xFE, 0x7F, 0x98, 0x1, 0xF8, 0x1F, 0x80, 0x19, 0xFE, 0x7F, 0x98, 0x0, 0xE0, 0x7, 0x0, 0x19, 0xFE, 0xFF, 0xB8, 0x0, 0xC0, 0x3, 0x0, 0x1D, 0xFF, 0xFF, 0x30, 0x1, 0x80, 0x1, 0x80, 0xC, 0xFF, 0xFF, 0x30, 0x1, 0x80, 0x1, 0x80, 0xC, 0xFF, 0xFF, 0x30, 0x3, 0x0, 0x0, 0xC0, 0xC, 0xFF, 0xFF, 0x30, 0x3, 0x0, 0x0, 0xC0, 0xC, 0xFF, 0xFF, 0x30, 0x3, 0x0, 0x0, 0xC0, 0xC, 0xFF, 0xFF, 0x30, 0x3, 0x18, 0x18, 0xC0, 0xC, 0xFF, 0xFF, 0x30, 0x3, 0x24, 0x24, 0xC0, 0xC, 0xFF, 0xFF, 0x30, 0x3, 0x24, 0x24, 0xC0, 0xC, 0xFF, 0xFF, 0x30, 0x1, 0x99, 0x99, 0x80, 0xC, 0xFF, 0xFF, 0x30, 0x1, 0x82, 0x41, 0x80, 0xC, 0xFF, 0xFF, 0xB8, 0x0, 0xC2, 0x43, 0x0, 0x1D, 0xFF, 0x7F, 0x98, 0x0, 0xE1, 0x87, 0x0, 0x19, 0xFE, 0x7F, 0x98, 0x1, 0xF8, 0x1F, 0x80, 0x19, 0xFE, 0x7F, 0xDC, 0x3, 0x9F, 0xF9, 0xC0, 0x3B, 0xFE, 0x7F, 0xCC, 0x7, 0x7, 0xE0, 0xE0, 0x33, 0xFE, 0x3F, 0xCE, 0xE, 0x0, 0x0, 0x70, 0x73, 0xFC, 0x3F, 0xE7, 0x3C, 0x0, 0x0, 0x3C, 0xE7, 0xFC, 0x1F, 0xF7, 0xF8, 0x0, 0x0, 0x1F, 0xEF, 0xF8, 0x1F, 0xF3, 0xF8, 0x0, 0x0, 0x1F, 0xCF, 0xF8, 0x1F, 0xF9, 0xF0, 0x0, 0x0, 0xF, 0x9F, 0xF8, 0xF, 0xFC, 0xF0, 0x0, 0x0, 0xF, 0x3F, 0xF0, 0x7, 0xFE, 0x78, 0x0, 0x0, 0x1E, 0x7F, 0xE0, 0x7, 0xFF, 0x3C, 0x0, 0x0, 0x3C, 0xFF, 0xE0, 0x3, 0xFF, 0x9F, 0x0, 0x0, 0xF9, 0xFF, 0xC0, 0x1, 0xFF, 0xC7, 0xE0, 0x7, 0xE3, 0xFF, 0x80, 0x1, 0xFF, 0xF1, 0xFF, 0xFF, 0x8F, 0xFF, 0x80, 0x0, 0xFF, 0xF8, 0x3F, 0xFC, 0x1F, 0xFF, 0x0, 0x0, 0x7F, 0xFF, 0x0, 0x0, 0xFF, 0xFE, 0x0, 0x0, 0x3F, 0xFF, 0xE0, 0x7, 0xFF, 0xFC, 0x0,};
const byte buttonMaskBitmap[] PROGMEM = {16, 24, 0x3, 0x0, 0xF, 0x80, 0x1F, 0xC0, 0x3F, 0xC0, 0x7F, 0xE0, 0xFF, 0xE0, 0xFF, 0xE0, 0x7F, 0xF0, 0x7F, 0xF0, 0x3F, 0xF0, 0x3F, 0xF0, 0x3F, 0xF0, 0x3F, 0xF0, 0x3F, 0xF0, 0x3F, 0xF0, 0x7F, 0xF0, 0x7F, 0xF0, 0xFF, 0xE0, 0xFF, 0xE0, 0x7F, 0xE0, 0x3F, 0xC0, 0x1F, 0xC0, 0xF, 0x80, 0x3, 0x0,};
const byte bottomBitmap[] PROGMEM = {16, 24, 0x1, 0x0, 0xA, 0x80, 0x15, 0x40, 0x2A, 0x80, 0x55, 0x40, 0xAA, 0xA0, 0x55, 0x40, 0x2A, 0xA0, 0x55, 0x50, 0x2A, 0xA0, 0x15, 0x50, 0x2A, 0xA0, 0x15, 0x50, 0x2A, 0xA0, 0x15, 0x50, 0x2A, 0xA0, 0x55, 0x50, 0xAA, 0xA0, 0x55, 0x40, 0x2A, 0xA0, 0x15, 0x40, 0xA, 0x80, 0x5, 0x0, 0x2, 0x0,};
const byte leftBitmap[] PROGMEM = {16, 24, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x80, 0x0, 0x0, 0x22, 0x20, 0x0, 0x0, 0x8, 0x80, 0x0, 0x0, 0x22, 0x20, 0x0, 0x0, 0x8, 0x80, 0x0, 0x0, 0x22, 0x20, 0x0, 0x0, 0x8, 0x80, 0x0, 0x0, 0x22, 0x20, 0x0, 0x0, 0x8, 0x80, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0,};
const byte rightBitmap[] PROGMEM = {16, 24, 0x3, 0x0, 0xA, 0x80, 0x1D, 0xC0, 0x2A, 0x80, 0x77, 0x60, 0xAA, 0xA0, 0xDD, 0xC0, 0x2A, 0xA0, 0x77, 0x70, 0x2A, 0xA0, 0x1D, 0xD0, 0x2A, 0xA0, 0x37, 0x70, 0x2A, 0xA0, 0x1D, 0xD0, 0x2A, 0xA0, 0x77, 0x70, 0xAA, 0xA0, 0xDD, 0xC0, 0x2A, 0xA0, 0x37, 0x40, 0xA, 0x80, 0xD, 0x80, 0x2, 0x0,};
const byte topBitmap[] PROGMEM = {16, 24, 0x2, 0x0, 0x0, 0x0, 0xA, 0x80, 0x4, 0x40, 0x2A, 0xA0, 0x0, 0x0, 0xAA, 0xA0, 0x44, 0x40, 0x2A, 0xA0, 0x0, 0x0, 0x2A, 0xA0, 0x4, 0x40, 0x2A, 0xA0, 0x0, 0x0, 0x2A, 0xA0, 0x44, 0x40, 0x2A, 0xA0, 0x0, 0x0, 0xAA, 0xA0, 0x44, 0x40, 0x2A, 0x80, 0x0, 0x0, 0xA, 0x80, 0x0, 0x0,};
const byte smileySmileBitmap[] PROGMEM = {16, 16, 0x7, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0x67, 0xE6, 0xCB, 0xD3, 0xCB, 0xD3, 0xCB, 0xD3, 0xE7, 0xE7, 0xFF, 0xFF, 0xC0, 0x3, 0x60, 0x6, 0x70, 0xE, 0x3C, 0x3C, 0x1F, 0xF8, 0x7, 0xE0,};

//SOUND PATTERNS made with FX Synth
const byte soundfx[5][8] = {
  {0, 0, 0, 12, 3, 4, 5, 8}, // sound 0  = up.
  {0, 12, 19, 8, 4, 4, 5, 6}, // sound 1 = right
  {0, 19, 13, 16, 4, 7, 5, 8}, // sound 2 = down.
  {0, 27, 6, 17, 4, 5, 5, 7}, // sound 3 = left.
  {0, 30, 57, 1, 5, 17, 4, 47}, // sound 4 = fail.
};

//GAMES Variables
#define timer_max 16 //delay to play 1 note.
#define NOTESMAX 53 //=== maximum notes stored in the array. !! add 2 to the desired limit.
#define NBNOTES 4 //maximum number of notes available

bool game_start = false;
bool display_top = true;
bool display_right = true;
bool display_bottom = true;
bool display_left = true;
bool game_difficulty = true;
bool melody_playing = true; // only when CPU plays the melody.
bool melody_all = false;//when RECORD acchieved, the melody is played entirely.
bool melody_fail = false;//if right --> reset game.

byte fail_timer = 0;
byte wait_timerstart = 0;
byte wait_timer = 0;
byte sound_play = 0; //which sound
byte melody[NOTESMAX];//size of the array storing the array.
byte melody_currentnote = 0;//
byte melody_step = 1;//increase each time a note is played & the player replicate this right note.
byte melody_timer = 0;
byte delay_timer = 0;

//SETUP
void setup() {
  gb.begin();
  initGame();
}
void initGame() {
  gb.titleScreen(titleBitmap); //gb.titleScreen(F("... a Simon clone."));
  //gb.changeGame();
  gb.pickRandomSeed(); //random notes each reset
  for (byte i = 0; i < (NOTESMAX - 1); i++) {
    melody[i - 1] = random(NBNOTES) + 1;
  }
  //RESET variables
  game_start = false;
  display_top = true;
  display_right = true;
  display_bottom = true;
  display_left = true;
  game_difficulty = true;
  melody_playing = true; // only when CPU plays the melody.
  melody_all = false;//when RECORD acchieved, the melody is played entirely.
  melody_fail = false;//if right --> reset game.
  fail_timer = 0;
  wait_timerstart = 0;
  wait_timer = 0;
  sound_play = 0; //which sound
  melody[NOTESMAX];//size of the array storing the array.
  melody_currentnote = 0;//
  melody_step = 1;//increase each time a note is played & the player replicate this right note.
  melody_timer = 0;
  delay_timer = 0;
}

void loop() {
  if (gb.update()) {
    key_reset();//to cancel at any time;

    //START delay
    if (game_start == false) {
      wait_timerstart ++;
      if (wait_timerstart > timer_max * 1) {
        melody_currentnote = 0; //reinitialize at the start : very important!!
        game_start = true;
      }
    }

    //IF RECORD achieved = hide background + show message + play entire melody!
    if ( melody_step >= (NOTESMAX - 1) ) {
      //endRecord();
      gb.display.setColor(BLACK);
      gb.display.drawBitmap(34, 16, smileySmileBitmap); // draw smiley
      gb.display.cursorX = 0;
      gb.display.cursorY = 0;
      gb.display.print(" CONGRATULATIONS!!\n \    \27 to reset");
      if (melody_all == false) melody_all == true; //play the whole string of notes?
    }
    else
    {
      //BACKGROUND
      gb.display.setColor(BLACK);
      gb.display.drawBitmap(10, 0, frameBitmap);
      //PLAYING TURNS
      if ((delay_timer == 0) && (game_start == true)) {
        if (melody_playing == true) {
          melodyPlaying();
        } else playerPlaying();
      }
      //delay after the player turn
      if (delay_timer > 0) {
        delay_timer ++;
        if (delay_timer > timer_max >> 1) delay_timer = 0;
      }
      //DRAW
      drawButtons();
    }//end record
  }//end update.
}//end loop.
